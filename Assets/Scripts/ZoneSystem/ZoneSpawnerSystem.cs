using Unity.Burst;‚Ä®using Unity.Collections;‚Ä®using Unity.Entities;‚Ä®using Unity.Mathematics;‚Ä®using Unity.Transforms;‚Ä®using Unity.Rendering;‚Ä®using Unity.Jobs;‚Ä®using UnityEngine;‚Ä®‚Ä®‚Ä®/// <summary>‚Ä®/// –°–∏—Å—Ç–µ–º–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ ZONE –∫–∞—Ä—Ç—ã (Hex Grid + —Ä–∞–¥–∏–∞—Ü–∏—è)‚Ä®/// –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –í–ú–ï–°–¢–û GridSpawnerSystem/HexGridSpawnerSystem‚Ä®/// </summary>‚Ä®[UpdateInGroup(typeof(InitializationSystemGroup))]‚Ä®public partial struct ZoneSpawnerSystem : ISystem‚Ä®{‚Ä®    [BurstCompile]‚Ä®    public void OnUpdate(ref SystemState state)‚Ä®    {‚Ä®        // üî• –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ GridConfig –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–Ω‚Ä®        var configQuery = SystemAPI.QueryBuilder().WithAll<GridConfig>().Build();‚Ä®        if (!configQuery.IsEmpty) return;‚Ä®‚Ä®        // üî• –ò—â–µ–º ZoneSpawnerComponent‚Ä®        var query = SystemAPI.QueryBuilder().WithAll<ZoneSpawnerComponent>().Build();‚Ä®        if (query.IsEmpty) return;‚Ä®‚Ä®        var spawnerEntities = query.ToEntityArray(Allocator.Temp);‚Ä®        var spawnerComponents = query.ToComponentDataArray<ZoneSpawnerComponent>(Allocator.Temp);‚Ä®‚Ä®        if (spawnerEntities.Length > 0)‚Ä®        {‚Ä®            var spawnerEntity = spawnerEntities[0];‚Ä®            var spawnerData = spawnerComponents[0];‚Ä®            var radiationConfig = state.EntityManager.GetComponentData<ZoneRadiationConfig>(spawnerEntity);‚Ä®            var baseGridColor = state.EntityManager.GetComponentData<ZoneBaseGridColor>(spawnerEntity);‚Ä®            var islandConfig = state.EntityManager.GetComponentData<ZoneIslandConfig>(spawnerEntity);‚Ä®‚Ä®            int qCount = spawnerData.GridSize.x;‚Ä®            int rCount = spawnerData.GridSize.y;‚Ä®            int totalCells = qCount * rCount;‚Ä®‚Ä®            Debug.Log($"[ZoneSpawnerSystem] Generating ZONE map {qCount}x{rCount}...");‚Ä®‚Ä®            // 1. –°–æ–∑–¥–∞–µ–º GridMap (—Å–æ–≤–º–µ—Å—Ç–∏–º–æ —Å –æ—Å–Ω–æ–≤–Ω—ã–º –∫–æ–¥–æ–º)‚Ä®            var mapEntity = state.EntityManager.CreateEntity();‚Ä®            state.EntityManager.SetName(mapEntity, "GridMap");‚Ä®            state.EntityManager.AddComponentData(mapEntity, new GridMapTag { Size = spawnerData.GridSize });‚Ä®            state.EntityManager.AddBuffer<GridCellElement>(mapEntity);‚Ä®‚Ä®            // üî• –î–æ–±–∞–≤–ª—è–µ–º –±—É—Ñ–µ—Ä —Ä–∞–¥–∏–∞—Ü–∏–∏ (–æ—Ç–¥–µ–ª—å–Ω—ã–π)‚Ä®            state.EntityManager.AddBuffer<ZoneCellRadiation>(mapEntity);‚Ä®            ‚Ä®            // üî• –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–∞–∑–æ–≤—ã–π —Ü–≤–µ—Ç –≥—Ä–∏–¥–∞ –Ω–∞ GridMap –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –¥–µ–±–∞–≥–∞ —Ä–∞–¥–∏–∞—Ü–∏–∏‚Ä®            state.EntityManager.AddComponentData(mapEntity, baseGridColor);‚Ä®‚Ä®            // 2. –°–æ–∑–¥–∞–µ–º GridConfig (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Å–∏—Å—Ç–µ–º–∞–º–∏ –¥–≤–∏–∂–µ–Ω–∏—è)‚Ä®            var configEntity = state.EntityManager.CreateEntity();‚Ä®            state.EntityManager.SetName(configEntity, "GridConfig");‚Ä®            state.EntityManager.AddComponentData(configEntity, new GridConfig‚Ä®            {‚Ä®                GridSize = spawnerData.GridSize,‚Ä®                BrushSize = new int2(1, 1),‚Ä®                Spacing = spawnerData.HexSize,‚Ä®                HeightSky = 3.0f,‚Ä®                HeightGround = 0.0f,‚Ä®                HeightUnderground = -3.0f,‚Ä®                FacingMode = UnitFacingMode.Free,‚Ä®                VisualMode = GridVisualMode.Cell, // Cell mode –¥–ª—è ZONE‚Ä®                Layout = GridLayoutType.HexFlatTop‚Ä®            });‚Ä®‚Ä®            // 3. –ò–Ω—Å—Ç–∞–Ω—Ü–∏—Ä—É–µ–º hex –∫–ª–µ—Ç–∫–∏‚Ä®            var instances = new NativeArray<Entity>(totalCells, Allocator.TempJob);‚Ä®            state.EntityManager.Instantiate(spawnerData.HexCellPrefab, instances);‚Ä®            state.EntityManager.AddComponent<GridCoordinates>(instances);‚Ä®            state.EntityManager.AddComponent<URPMaterialPropertyBaseColor>(instances);‚Ä®            state.EntityManager.AddComponent<CellCustomColor>(instances); // üî• –î–ª—è –∫–∞—Å—Ç–æ–º–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤‚Ä®            // üî• FIX: –≤—Ä—É—á–Ω—É—é –∑–∞–¥–∞—ë–º RenderBounds –¥–ª—è –≤—Å–µ—Ö hex-–∫–ª–µ—Ç–æ–∫‚Ä®var renderBounds = new RenderBounds‚Ä®{‚Ä®    Value = new AABB‚Ä®    {‚Ä®        Center = float3.zero,‚Ä®        Extents = new float3(‚Ä®            spawnerData.GridSize.x * spawnerData.HexSize,‚Ä®            10f,‚Ä®            spawnerData.GridSize.y * spawnerData.HexSize‚Ä®        )‚Ä®    }‚Ä®};‚Ä®‚Ä®if (!state.EntityManager.HasComponent<RenderBounds>(instances[0]))‚Ä®    state.EntityManager.AddComponent<RenderBounds>(instances);‚Ä®‚Ä®for (int i = 0; i < instances.Length; i++)‚Ä®    state.EntityManager.SetComponentData(instances[i], renderBounds);‚Ä®‚Ä®‚Ä®            // 4. –ü–æ–ª—É—á–∞–µ–º –±—É—Ñ–µ—Ä—ã‚Ä®            var mapBuffer = state.EntityManager.GetBuffer<GridCellElement>(mapEntity);‚Ä®            var radiationBuffer = state.EntityManager.GetBuffer<ZoneCellRadiation>(mapEntity);‚Ä®            mapBuffer.ResizeUninitialized(totalCells);‚Ä®            radiationBuffer.ResizeUninitialized(totalCells);‚Ä®‚Ä®            // 5. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ Job (–±–∞–∑–æ–≤–∞—è Yellow –∫–∞—Ä—Ç–∞)‚Ä®            var initJob = new InitializeZoneGridJob‚Ä®            {‚Ä®                Instances = instances,‚Ä®                GridSize = new int2(qCount, rCount),‚Ä®                HexSize = spawnerData.HexSize,‚Ä®                YellowRadiation = radiationConfig.LevelYellow,‚Ä®                BaseGrayColor = baseGridColor.Color, // üî• –ò–ó–ú–ï–ù–ï–ù–û: –±–∞–∑–æ–≤—ã–π —Å–µ—Ä—ã–π —Ü–≤–µ—Ç‚Ä®                Transforms = state.GetComponentLookup<LocalTransform>(false),‚Ä®                Coordinates = state.GetComponentLookup<GridCoordinates>(false),‚Ä®                Colors = state.GetComponentLookup<URPMaterialPropertyBaseColor>(false),‚Ä®                CustomColors = state.GetComponentLookup<CellCustomColor>(false),‚Ä®                MapBuffer = mapBuffer,‚Ä®                RadiationBuffer = radiationBuffer‚Ä®            };‚Ä®‚Ä®            var jobHandle = initJob.Schedule(totalCells, 64);‚Ä®            jobHandle.Complete();‚Ä®‚Ä®            // üî• 6. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Å—Ç—Ä–æ–≤–æ–≤ —Ä–∞–¥–∏–∞—Ü–∏–∏‚Ä®            // ‚úÖ –ü–æ–ª–Ω–æ—Å—Ç—å—é Burst-—Å–æ–≤–º–µ—Å—Ç–∏–º–æ‚Ä®            double time = SystemAPI.Time.ElapsedTime;‚Ä®            uint frameCount = (uint)UnityEngine.Time.frameCount; // –≠—Ç–æ –º–æ–∂–Ω–æ –≤—ã–∑—ã–≤–∞—Ç—å –≤–Ω–µ Burst‚Ä®‚Ä®            // –°–æ–∑–¥–∞—ë–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π seed –∏–∑ –≤—Ä–µ–º–µ–Ω–∏ –∏ —Å—á—ë—Ç—á–∏–∫–∞ –∫–∞–¥—Ä–æ–≤‚Ä®            uint seed = math.hash(new uint2(‚Ä®                (uint)(time * 1000000.0),‚Ä®                frameCount‚Ä®            ));‚Ä®‚Ä®           // var random = Unity.Mathematics.Random.CreateFromIndex(seed);‚Ä®            ZoneIslandGenerator.GenerateGreenIslands(radiationBuffer, spawnerData.GridSize, radiationConfig, islandConfig, seed);‚Ä®            ZoneIslandGenerator.GenerateOrangeIslands(radiationBuffer, spawnerData.GridSize, radiationConfig, islandConfig, (seed + 1000));‚Ä®            ZoneIslandGenerator.GenerateRedIslands(radiationBuffer, spawnerData.GridSize, radiationConfig, islandConfig, (seed + 2000));‚Ä®‚Ä®            // üî• 7. –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ü–≤–µ—Ç–æ–≤ –∫ –∫–ª–µ—Ç–∫–∞–º‚Ä®            //ApplyRadiationColorsToCells(radiationBuffer, radiationConfig, colorsLookup: state.GetComponentLookup<URPMaterialPropertyBaseColor>(false), customColorsLookup: state.GetComponentLookup<CellCustomColor>(false));‚Ä®‚Ä®            instances.Dispose();‚Ä®‚Ä®        }‚Ä®    }‚Ä®‚Ä®    /// <summary>‚Ä®    /// –ü—Ä–∏–º–µ–Ω—è–µ—Ç —Ü–≤–µ—Ç–∞ —Ä–∞–¥–∏–∞—Ü–∏–∏ –∫–æ –≤—Å–µ–º –∫–ª–µ—Ç–∫–∞–º‚Ä®    /// </summary>‚Ä®    private static void ApplyRadiationColorsToCells(‚Ä®        DynamicBuffer<ZoneCellRadiation> radiationBuffer,‚Ä®        ZoneRadiationConfig radiationConfig,‚Ä®        ComponentLookup<URPMaterialPropertyBaseColor> colorsLookup,‚Ä®        ComponentLookup<CellCustomColor> customColorsLookup)‚Ä®    {‚Ä®        for (int i = 0; i < radiationBuffer.Length; i++)‚Ä®        {‚Ä®            var radiation = radiationBuffer[i];‚Ä®‚Ä®            float4 cellColor;‚Ä®            switch (radiation.RadiationLevel)‚Ä®            {‚Ä®                case 0: cellColor = radiationConfig.ColorGreen; break;‚Ä®                case 5: cellColor = radiationConfig.ColorYellow; break;‚Ä®                case 10: cellColor = radiationConfig.ColorOrange; break;‚Ä®                case 15: cellColor = radiationConfig.ColorRed; break;‚Ä®                default: cellColor = radiationConfig.ColorYellow; break;‚Ä®            }‚Ä®‚Ä®            var cellEntity = radiationBuffer[i].CellEntity; // üî• –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å CellEntity –≤ ZoneCellRadiation!‚Ä®            if (colorsLookup.HasComponent(cellEntity))‚Ä®                colorsLookup[cellEntity] = new URPMaterialPropertyBaseColor { Value = cellColor };‚Ä®            if (customColorsLookup.HasComponent(cellEntity))‚Ä®                customColorsLookup[cellEntity] = new CellCustomColor { BaseColor = cellColor };‚Ä®        }‚Ä®    }‚Ä®‚Ä®‚Ä®    /// <summary>‚Ä®    /// Burst Job –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ZONE –∫–∞—Ä—Ç—ã (–≤—Å–µ –∫–ª–µ—Ç–∫–∏ Yellow)‚Ä®    /// </summary>‚Ä®    [BurstCompile]‚Ä®    private struct InitializeZoneGridJob : IJobParallelFor‚Ä®    {‚Ä®        [ReadOnly] public NativeArray<Entity> Instances;‚Ä®        [ReadOnly] public int2 GridSize;‚Ä®        [ReadOnly] public float HexSize;‚Ä®        [ReadOnly] public int YellowRadiation;‚Ä®        [ReadOnly] public float4 BaseGrayColor;‚Ä®‚Ä®‚Ä®        [NativeDisableParallelForRestriction] public ComponentLookup<LocalTransform> Transforms;‚Ä®        [NativeDisableParallelForRestriction] public ComponentLookup<GridCoordinates> Coordinates;‚Ä®        [NativeDisableParallelForRestriction] public ComponentLookup<URPMaterialPropertyBaseColor> Colors;‚Ä®        [NativeDisableParallelForRestriction] public ComponentLookup<CellCustomColor> CustomColors;‚Ä®        [NativeDisableParallelForRestriction] public DynamicBuffer<GridCellElement> MapBuffer;‚Ä®        [NativeDisableParallelForRestriction] public DynamicBuffer<ZoneCellRadiation> RadiationBuffer;‚Ä®‚Ä®        public void Execute(int index)‚Ä®        {‚Ä®            int x = index % GridSize.x;   // –∫–æ–ª–æ–Ω–∫–∞ (X ‚Üí –ø—Ä–∞–≤–æ)‚Ä®    int z = index / GridSize.x;   // —Å—Ç—Ä–æ–∫–∞ (Z ‚Üí –≤–≤–µ—Ä—Ö)‚Ä®‚Ä®    // odd-q offset ‚Üí axial (FlatTop)‚Ä®    int q = x;‚Ä®            int r = z - (x >> 1);‚Ä®‚Ä®            var instance = Instances[index];‚Ä®‚Ä®            float3 pos = HexGridUtils.HexAxialToWorld(new int2(q, r), HexSize);‚Ä®            Transforms[instance] = LocalTransform.FromPositionRotation(pos, quaternion.identity);‚Ä®‚Ä®            Coordinates[instance] = new GridCoordinates‚Ä®            {‚Ä®                Value = new int2(q, r)‚Ä®            };‚Ä®‚Ä®            Colors[instance] = new URPMaterialPropertyBaseColor { Value = BaseGrayColor };‚Ä®            CustomColors[instance] = new CellCustomColor { BaseColor = BaseGrayColor };‚Ä®‚Ä®            MapBuffer[index] = new GridCellElement‚Ä®            {‚Ä®                CellEntity = instance,‚Ä®                IsOccupiedGround = false,‚Ä®                IsOccupiedUnderground = false,‚Ä®                IsOccupiedSky = false,‚Ä®                OccupantGround = Entity.Null,‚Ä®                OccupantUnderground = Entity.Null,‚Ä®                OccupantSky = Entity.Null,‚Ä®                IsHighlighted = false‚Ä®            };‚Ä®‚Ä®            RadiationBuffer[index] = new ZoneCellRadiation‚Ä®            {‚Ä®                GridPos = new int2(q, r),‚Ä®                CellEntity = instance,‚Ä®                RadiationLevel = YellowRadiation,‚Ä®                IsVisited = false‚Ä®            };‚Ä®        }‚Ä®‚Ä®    }‚Ä®}‚Ä®